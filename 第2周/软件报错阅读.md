软件报错阅读

```
System.Exception: DayView: Loading timeline exception:

---
Finkit.ManicTime.Common.Messaging.MessageHandlerException: Error executing message handler:
Microsoft.Data.Sqlite.SqliteException: SQLite Error 13: 'database or disk is full'.
   at Microsoft.Data.Sqlite.SqliteException.ThrowExceptionForRC(Int32 rc, sqlite3 db)
   at Microsoft.Data.Sqlite.SqliteDataReader.NextResult()
   at Microsoft.Data.Sqlite.SqliteCommand.ExecuteReader(CommandBehavior behavior)
   at Microsoft.Data.Sqlite.SqliteCommand.ExecuteReader()
   at Microsoft.Data.Sqlite.SqliteCommand.ExecuteNonQuery()
   at System.Data.Common.DbCommand.ExecuteNonQueryAsync(CancellationToken cancellationToken)
--- End of stack trace from previous location where exception was thrown ---
   at Shared.Storage.Sqlite.SqliteDatabaseTransaction.ExecuteNonQueryAsync(String sql, DbQueryParameter[] parameters, CancellationToken cancellationToken)
   at Shared.Storage.DocumentDb.Sql.SqlDocumentDatabaseProviderTransaction.UpdateAsync(String documentType, DocumentRow row, String newTimestamp, CancellationToken cancellationToken)
   at Shared.Storage.DocumentDb.DocumentDatabaseTransaction.UpdateAsync[T](T document, CancellationToken cancellationToken)
   at Shared.Storage.DocumentDb.SqlDocumentDatabase.UpdateAsync[T](IDatabaseTransaction transaction, T document, CancellationToken cancellationToken)
   at Shared.Storage.Databases.Sql.Timelines.SqlTimelineDatabase.SaveTimelineAsync(IDatabaseTransaction transaction, Timeline updatedTimeline, CancellationToken cancellationToken)
   at Shared.Storage.Databases.Sql.Timelines.SqlTimelineDatabase.SaveTimelineAsync(Timeline currentTimeline, Timeline updatedTimeline, EntitySourceMapEntry[] entitySourceCreates, EntitySourceMapEntry[] entitySourceUpdates, TimelineHistoryEntry timelineHistoryEntry, Func`4 saveChangeLogAsync, CancellationToken cancellationToken)
   at Shared.Storage.Databases.Sql.Timelines.SqlTimelineDatabase.SaveTimelineAsync(Timeline currentTimeline, Timeline updatedTimeline, IDictionary`2 changesToAddByChangeLogKey, EntitySourceMapEntry[] entitySourceCreates, EntitySourceMapEntry[] entitySourceUpdates, TimelineHistoryEntry timelineHistoryEntry, CancellationToken cancellationToken)
   at Shared.Storage.Timelines.TimelineService.SaveTimelineAsync(Timeline timelineBeforeUpdate, Timeline timelineAfterUpdate, IDictionary`2 changesToAddByChangeLogKey, TimelineHistoryEntry timelineHistoryEntry, CancellationToken cancellationToken, EntitySourceMapEntry[] entitySourceMapCreates, EntitySourceMapEntry[] entitySourceMapUpdates, Boolean checkMaxTimelineEnvironments)
   at Shared.Storage.Timelines.TimelineService.AddChangesAsync(Timeline timeline, IEnumerable`1 changes, TimelinePropertyUpdates propertyUpdates, DeviceUpdateState deviceUpdateState, IDictionary`2 sourceIdMap, SystemEnvironment environment, Boolean isEnvironmentHome, CancellationToken cancellationToken)
   at ManicTime.Client.Tracker.Storage.LocalStoreWriting.LocalStoreTimelineWriter.<>c__DisplayClass25_0.<<CommitChangesAsync>b__0>d.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at ManicTime.Client.Tracker.Storage.LocalStoreWriting.LocalStoreTimelineWriter.DoExecuteTimelineService(Func`2 asyncAction, CancellationToken cancellationToken)
   at ManicTime.Client.Tracker.Storage.LocalStoreWriting.LocalStoreTimelineWriter.CommitChangesAsync(Timeline timeline, Change[] changes, CancellationToken cancellationToken)
   at ManicTime.Client.Tracker.Storage.LocalStoreWriting.LocalStoreTimelineWriter.CommitBatchAsync(LocalStoreBatch batch, CancellationToken cancellationToken)
   at ManicTime.Client.Tracker.Storage.LocalStoreWriting.LocalStoreTimelineWriter.FlushAsync(CancellationToken cancellationToken)
   at ManicTime.Client.Tracker.LocalStoreWriting.TrackerFlushScheduler.(TimeSpan , Boolean , TimeSpan , CancellationToken )
   at Finkit.ManicTime.Tracker.Timelines.Messaging.DayViewActivitiesMessageHandler.FlushLocalStoreIfNeededOrSetMessage(IEnumerable`1 timelineKeys, DateTime fromLocalTime, DateTime toLocalTime, CancellationToken cancellationToken)
   at Finkit.ManicTime.Tracker.Timelines.Messaging.DayViewActivitiesMessageHandler.Handle(GetDayViewActivitiesRequest message, CancellationToken cancellationToken)
   at Finkit.ManicTime.Common.Messaging.MessageServerHandlerRegistry.<>c__DisplayClass5_0.<<CreateDelegate>b__1>d.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at Finkit.ManicTime.Common.Messaging.MessageServer.<>c__DisplayClass16_0.<<HandleMessage>b__0>d.MoveNext()

   at Finkit.ManicTime.Common.Messaging.MessageClient.SendAsync(IMessage message, Boolean waitForResult, Func`3 onItemReady, CancellationToken cancellationToken)
   at Finkit.ManicTime.Common.Messaging.MessageClient.GetAsync[T](IMessage`1 message, CancellationToken cancellationToken)
   at Finkit.ManicTime.Common.Messaging.MessageClientExtensions.SendWithTimeoutAsync[T](IMessage`1 message, Func`3 sendAsync, TimeSpan timeout, Int32 timeoutRetryCount, CancellationToken cancellationToken)
   at Finkit.ManicTime.Client.Timelines.Messaging.DayViewActivitiesMessageClient.GetDayViewActivities(Dictionary`2 timelinesWithTimestamps, DateTime fromLocalTime, DateTime toLocalTime, CancellationToken cancellationToken)
   at Finkit.ManicTime.Client.Plugins.LocalServerType.LocalDayViewLoader.BeginLoad(Dictionary`2 timelinesWithTimestamps, DateTime fromLocalTime, DateTime toLocalTime, Action`2 onLoadComplete)

***ManicTime Version 4.5.12.0
```



