第三周 信息检索技术作业

1-1

```R
# 定义文档集合
docs <- c("breakthrough drug for schizophrenia",
          "new schizophrenia drug",
          "new approach for treatment of schizophrenia",
          "new hopes for schizophrenia patients")

# 创建词项-文档矩阵
library(tm)
corpus <- Corpus(VectorSource(docs))
dtm <- DocumentTermMatrix(corpus)
matrix <- as.matrix(dtm)

# 输出词项-文档矩阵
print(matrix)

# 创建倒排索引
library(qdap)
terms <- colnames(matrix)
inverted_index <- data.frame(
  Term = character(),
  Doc_Position = integer(),
  stringsAsFactors = FALSE)
for (i in 1:length(terms)) {
  term <- terms[i]
  positions <- which(matrix[, i] == 1)
  for (j in 1:length(positions)) {
    position <- positions[j]
    inverted_index <- rbind(inverted_index, 
                            data.frame(Term = term, 
                                       Doc_Position = position))
  }
}

# 输出倒排索引
print(inverted_index)

```

problems about this piece of code and help me explain it more specifically thx

The code is performing the following operations:

1. Creating a collection of documents represented as character strings.
2. Creating a document-term matrix (DTM) using the "tm" package, which represents the frequency of each term (word) in each document.
3. Creating an inverted index from the DTM using the "qdap" package, which lists the positions of each term in each document.

Now, let's take a closer look at the code:

1. The `docs` variable is a character vector containing the four documents.
2. The `tm` package is used to create a `Corpus` object from the `docs` vector, which is then converted to a DTM using the `DocumentTermMatrix` function. The resulting `dtm` object is then converted to a matrix using the `as.matrix` function and stored in the `matrix` variable.
3. The `colnames` function is used to extract the terms from the DTM, which are stored in the `terms` variable. The `qdap` package is then used to create an empty data frame called `inverted_index` with two columns: `Term` and `Doc_Position`.
4. A `for` loop is used to iterate over each term in the `terms` vector. For each term, the positions of that term in each document are identified using the `which` function. Another `for` loop is then used to iterate over each position and add a row to the `inverted_index` data frame, containing the term and the document position.

Finally, the resulting `matrix` and `inverted_index` are printed to the console using the `print` function.

It's worth noting that this code is a very basic example of how to create a document-term matrix and inverted index. In practice, there are many additional steps that would typically be taken, such as text preprocessing (e.g., removing stop words, stemming, etc.), and more advanced techniques for handling text data (e.g., using machine learning models).



看r代码的时候很难把数据处理步骤和具体的命令对应起来
不知道每段代码对应实现的自然语言要求处理的操作是什么



词项文档矩阵

```
Docs breakthrough drug for schizophrenia new approach treatment hopes patients
   1            1    1   1             1   0        0         0     0        0
   2            0    1   0             1   1        0         0     0        0
   3            0    0   1             1   1        1         1     0        0
   4            0    0   1             1   1        0         0     1        1
```

文档集的倒排索引

```
            Term Doc_Position
1   breakthrough            1
11          drug            1
2           drug            2
12           for            1
3            for            3
4            for            4
13 schizophrenia            1
21 schizophrenia            2
31 schizophrenia            3
41 schizophrenia            4
22           new            2
32           new            3
42           new            4
33      approach            3
34     treatment            3
43         hopes            4
44      patients            4
```



1-4

```
可以
```

1-9

检索包含的词项 前面的词项出现频率很高, 后面词项出现频率很低, 按照从大到小的方式进行

For queries involving logic and structure, is processing in ascending order according to the inverted index table necessarily optimal? If yes, please provide an explanation; if not, please provide a counterexample

In general, processing queries in ascending order according to the inverted index table can be a reasonable approach, ==but it is not necessarily optimal== in all cases.

The inverted index is a data structure that stores a list of all the documents in which each word appears, along with the positions of those words within each document. When processing a query, the system can use the inverted index to quickly identify which documents contain the query terms and where those terms appear in each document.

In some cases, processing the query terms in ascending order ==according to the inverted index can be an effective way to reduce the search space and speed up processing==. For example, if a query contains multiple terms and the first term has a much lower document frequency than the others, processing that term first can eliminate a large portion of the documents from consideration, making subsequent processing faster.

> 不知道这里排除的逻辑是什么

However, there are also cases where ==processing in ascending order according to the inverted index is not optimal==. For example, consider a query that contains two terms, one of which has a very high document frequency and the other of which has a very low document frequency. In this case, processing the low-frequency term first may be more efficient, as it will reduce the search space more effectively than processing the high-frequency term first.

> 上下两种都是先处理出现频率低的

In general, the optimal processing order for a query will depend on a variety of factors, including the query structure, the characteristics of the inverted index, and the specific search algorithm being used.

1-10

```
union(p1,p2)
answer <- ()
while p1 != NIL and p2 != NIL
do if docID(p1) != docID(p2)
	then Add(answer,docID(p1),docID(p2))
    p1 <- next(p1)
    p2 <- next(p2)
return answer
```

1-11

```
原始方法要将其x and NOT y拆分成为两个查询 x 和 NOT y
需要扫描整个文档排除满足y的文档
```

```
andnot(p1,p2)
answer <- ()
while p1 != NIL and p2 != NIL
do if docID(p1) == docID(p2) and docID(p2) != y
	then ADD(answer,docID(p1))
    p1 <- next(p1)
    p2 <- next(p2)
return answer
```





